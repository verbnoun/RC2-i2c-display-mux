#!/bin/bash
# Universal Pico Console Connector
# Usage: ./console

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
BAUD_RATE="115200"
LOG_DIR="/Users/jackson/Documents/Projects/Attach Part/Product/SoftwareC/logs"

echo -e "${BLUE}🔌 Pico Console Connector${NC}"
echo

# Find all USB serial devices
DEVICES=($(ls /dev/tty.usbmodem* /dev/cu.usbmodem* 2>/dev/null | sort -u))

if [ ${#DEVICES[@]} -eq 0 ]; then
    echo -e "${RED}❌ No USB devices found${NC}"
    echo
    echo "Make sure your Pico is:"
    echo "  • Connected via USB"
    echo "  • Running firmware with USB serial enabled"
    exit 1
fi

# Select device
if [ ${#DEVICES[@]} -eq 1 ]; then
    # Only one device, use it
    DEVICE="${DEVICES[0]}"
    echo -e "${GREEN}✓ Found device: $DEVICE${NC}"
else
    # Multiple devices, let user choose
    echo -e "${CYAN}Multiple devices found:${NC}"
    echo
    for i in "${!DEVICES[@]}"; do
        echo "  $((i+1))) ${DEVICES[$i]}"
    done
    echo
    read -p "Select device (1-${#DEVICES[@]}): " choice
    
    # Validate choice
    if [[ "$choice" -ge 1 && "$choice" -le ${#DEVICES[@]} ]]; then
        DEVICE="${DEVICES[$((choice-1))]}"
        echo -e "${GREEN}✓ Selected: $DEVICE${NC}"
    else
        echo -e "${RED}Invalid selection${NC}"
        exit 1
    fi
fi

echo

# Check for picocom
if ! command -v picocom &> /dev/null; then
    echo -e "${RED}❌ picocom not installed${NC}"
    echo "Install with: brew install picocom"
    echo
    echo "Falling back to screen..."
    
    if ! command -v screen &> /dev/null; then
        echo -e "${RED}❌ screen not installed either${NC}"
        exit 1
    fi
    
    USE_SCREEN=true
else
    USE_SCREEN=false
fi

# Check for timestamp utility
HAS_TS=false
if command -v ts &> /dev/null; then
    HAS_TS=true
    echo -e "${GREEN}✓ Timestamps enabled${NC}"
else
    echo -e "${YELLOW}⚠ Install 'moreutils' for timestamps: brew install moreutils${NC}"
fi

# Create log directory if needed
mkdir -p "$LOG_DIR"

# Log cleanup function
cleanup_logs() {
    local log_count=$(ls -1 "$LOG_DIR"/console_*.log 2>/dev/null | wc -l)
    local log_size=$(du -sh "$LOG_DIR" 2>/dev/null | cut -f1)
    
    if [ "$log_count" -gt 0 ]; then
        echo -e "${CYAN}📊 Log Statistics:${NC}"
        echo "  Count: $log_count log files"
        echo "  Size:  $log_size"
        echo
        
        echo -e "${YELLOW}Clean old logs?${NC}"
        read -p "Delete old logs? [Y/n]: " clean_choice
        clean_choice=${clean_choice:-Y}  # Default to Y if empty
        
        if [[ "$clean_choice" =~ ^[Yy]$ ]]; then
            if [ "$log_count" -gt 0 ]; then
                rm -f "$LOG_DIR"/console_*.log
                echo -e "${GREEN}✓ Cleaned all $log_count old log files${NC}"
            else
                echo -e "${GREEN}✓ No logs to clean${NC}"
            fi
            echo
        fi
    fi
}

# Run log cleanup check
cleanup_logs

LOG_FILE="$LOG_DIR/console_$(date +%Y%m%d_%H%M%S).log"

# Display info
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${YELLOW}Device:${NC}     $DEVICE"
echo -e "${YELLOW}Baud:${NC}       $BAUD_RATE"
echo -e "${YELLOW}Timestamps:${NC} $([ "$HAS_TS" = true ] && echo "Yes" || echo "No")"
echo -e "${YELLOW}Log:${NC}        $LOG_FILE"
echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo

# Show commands if this looks like ValidateC pot_reader
echo -e "${CYAN}If running ValidateC pot_reader, commands:${NC}"
echo "  s - Show status"
echo "  a - Show all pot values"
echo "  r - Reset min/max values"
echo "  c - Calibrate"
echo "  b - ${GREEN}Reboot to BOOTSEL (for firmware updates!)${NC}"
echo "  h - Help"
echo

# Show exit instructions and auto-reconnect info
echo -e "${CYAN}🔄 Auto-reconnect enabled - console will stay open through flashing/reboots${NC}"
if [ "$USE_SCREEN" = true ]; then
    echo -e "${YELLOW}To exit: Ctrl+A, then K, then Y${NC}"
else
    echo -e "${YELLOW}To exit: Ctrl+A, Ctrl+X${NC}"
fi
echo
echo "Connecting..."
sleep 1

# Auto-reconnect loop - stays open through device reboots
RECONNECT_COUNT=0
while true; do
    # Show reconnect count if not first connection
    if [ $RECONNECT_COUNT -gt 0 ]; then
        echo
        echo -e "${CYAN}🔄 Reconnecting (attempt $RECONNECT_COUNT)...${NC}"
    fi

    # Check if device exists before connecting
    if [ ! -e "$DEVICE" ]; then
        echo -e "${YELLOW}⏳ Waiting for device to appear...${NC}"
        for i in {1..10}; do
            if [ -e "$DEVICE" ]; then
                echo -e "${GREEN}✓ Device reappeared!${NC}"
                sleep 0.5  # Let USB settle
                break
            fi
            sleep 1
        done

        # If device still doesn't exist, exit
        if [ ! -e "$DEVICE" ]; then
            echo -e "${RED}❌ Device did not reappear - exiting${NC}"
            break
        fi
    fi

    # Connect to device
    if [ "$USE_SCREEN" = true ]; then
        if [ "$HAS_TS" = true ]; then
            echo "Note: Screen doesn't support live timestamps. Check log file for timestamps."
        fi
        screen -L -Logfile "$LOG_FILE" "$DEVICE" "$BAUD_RATE"
        EXIT_CODE=$?
    else
        if [ "$HAS_TS" = true ]; then
            picocom -b "$BAUD_RATE" --imap lfcrlf --echo "$DEVICE" | ts '[%H:%M:%S.%.S]' | tee -a "$LOG_FILE"
            EXIT_CODE=$?
        else
            picocom -b "$BAUD_RATE" --imap lfcrlf --echo "$DEVICE" | tee -a "$LOG_FILE"
            EXIT_CODE=$?
        fi
    fi

    # Check exit reason
    # picocom returns 0 for user exit (Ctrl+A Ctrl+X), non-zero for errors/disconnects
    # BUT we need to check if device still exists to distinguish user exit from disconnect
    if [ $EXIT_CODE -eq 0 ] && [ -e "$DEVICE" ]; then
        # Clean exit by user AND device still exists
        echo -e "${GREEN}✓ Console session ended by user${NC}"
        break
    else
        # Device disconnected (likely reboot/flash) OR error exit
        echo -e "${YELLOW}⚠️  Device disconnected (exit code: $EXIT_CODE) - checking for reconnect...${NC}"
        RECONNECT_COUNT=$((RECONNECT_COUNT + 1))
        sleep 1
        # Loop will retry connection
    fi
done

echo
echo -e "Log saved to: ${YELLOW}$LOG_FILE${NC}"