#!/bin/bash
# Universal Pico Console Connector
# Usage: ./console

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
BAUD_RATE="115200"
LOG_DIR="/Users/jackson/Documents/Projects/Attach Part/Product/SoftwareC/logs"

echo -e "${BLUE}ğŸ”Œ Pico Console Connector${NC}"
echo

# Find all USB serial devices
DEVICES=($(ls /dev/tty.usbmodem* /dev/cu.usbmodem* 2>/dev/null | sort -u))

if [ ${#DEVICES[@]} -eq 0 ]; then
    echo -e "${RED}âŒ No USB devices found${NC}"
    echo
    echo "Make sure your Pico is:"
    echo "  â€¢ Connected via USB"
    echo "  â€¢ Running firmware with USB serial enabled"
    exit 1
fi

# Select device
if [ ${#DEVICES[@]} -eq 1 ]; then
    # Only one device, use it
    DEVICE="${DEVICES[0]}"
    echo -e "${GREEN}âœ“ Found device: $DEVICE${NC}"
else
    # Multiple devices, let user choose
    echo -e "${CYAN}Multiple devices found:${NC}"
    echo
    for i in "${!DEVICES[@]}"; do
        echo "  $((i+1))) ${DEVICES[$i]}"
    done
    echo
    read -p "Select device (1-${#DEVICES[@]}): " choice
    
    # Validate choice
    if [[ "$choice" -ge 1 && "$choice" -le ${#DEVICES[@]} ]]; then
        DEVICE="${DEVICES[$((choice-1))]}"
        echo -e "${GREEN}âœ“ Selected: $DEVICE${NC}"
    else
        echo -e "${RED}Invalid selection${NC}"
        exit 1
    fi
fi

echo

# Check for picocom
if ! command -v picocom &> /dev/null; then
    echo -e "${RED}âŒ picocom not installed${NC}"
    echo "Install with: brew install picocom"
    echo
    echo "Falling back to screen..."
    
    if ! command -v screen &> /dev/null; then
        echo -e "${RED}âŒ screen not installed either${NC}"
        exit 1
    fi
    
    USE_SCREEN=true
else
    USE_SCREEN=false
fi

# Check for timestamp utility
HAS_TS=false
if command -v ts &> /dev/null; then
    HAS_TS=true
    echo -e "${GREEN}âœ“ Timestamps enabled${NC}"
else
    echo -e "${YELLOW}âš  Install 'moreutils' for timestamps: brew install moreutils${NC}"
fi

# Create log directory if needed
mkdir -p "$LOG_DIR"

# Log cleanup function
cleanup_logs() {
    local log_count=$(ls -1 "$LOG_DIR"/console_*.log 2>/dev/null | wc -l)
    local log_size=$(du -sh "$LOG_DIR" 2>/dev/null | cut -f1)
    
    if [ "$log_count" -gt 0 ]; then
        echo -e "${CYAN}ğŸ“Š Log Statistics:${NC}"
        echo "  Count: $log_count log files"
        echo "  Size:  $log_size"
        echo
        
        echo -e "${YELLOW}Clean old logs?${NC}"
        read -p "Delete old logs? [Y/n]: " clean_choice
        clean_choice=${clean_choice:-Y}  # Default to Y if empty
        
        if [[ "$clean_choice" =~ ^[Yy]$ ]]; then
            if [ "$log_count" -gt 0 ]; then
                rm -f "$LOG_DIR"/console_*.log
                echo -e "${GREEN}âœ“ Cleaned all $log_count old log files${NC}"
            else
                echo -e "${GREEN}âœ“ No logs to clean${NC}"
            fi
            echo
        fi
    fi
}

# Run log cleanup check
cleanup_logs

LOG_FILE="$LOG_DIR/console_$(date +%Y%m%d_%H%M%S).log"

# Display info
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${YELLOW}Device:${NC}     $DEVICE"
echo -e "${YELLOW}Baud:${NC}       $BAUD_RATE"
echo -e "${YELLOW}Timestamps:${NC} $([ "$HAS_TS" = true ] && echo "Yes" || echo "No")"
echo -e "${YELLOW}Log:${NC}        $LOG_FILE"
echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo

# Show commands if this looks like ValidateC pot_reader
echo -e "${CYAN}If running ValidateC pot_reader, commands:${NC}"
echo "  s - Show status"
echo "  a - Show all pot values"
echo "  r - Reset min/max values"
echo "  c - Calibrate"
echo "  b - ${GREEN}Reboot to BOOTSEL (for firmware updates!)${NC}"
echo "  h - Help"
echo

# Show exit instructions
if [ "$USE_SCREEN" = true ]; then
    echo -e "${YELLOW}To exit: Ctrl+A, then K, then Y${NC}"
    echo
    echo "Connecting..."
    sleep 1
    
    # Use screen with logging (screen doesn't support piped timestamps easily)
    if [ "$HAS_TS" = true ]; then
        # Create a wrapper script for screen with timestamps
        echo "Note: Screen doesn't support live timestamps. Check log file for timestamps."
    fi
    screen -L -Logfile "$LOG_FILE" "$DEVICE" "$BAUD_RATE"
else
    echo -e "${YELLOW}To exit: Ctrl+A, Ctrl+X${NC}"
    echo
    echo "Connecting..."
    sleep 1
    
    if [ "$HAS_TS" = true ]; then
        # Use picocom with millisecond timestamps
        picocom -b "$BAUD_RATE" --imap lfcrlf --echo "$DEVICE" | ts '[%H:%M:%S.%.S]' | tee "$LOG_FILE"
    else
        # Use picocom without timestamps but still log
        picocom -b "$BAUD_RATE" --imap lfcrlf --echo "$DEVICE" | tee "$LOG_FILE"
    fi
fi

echo
echo -e "${GREEN}âœ“ Console session ended${NC}"
echo -e "Log saved to: ${YELLOW}$LOG_FILE${NC}"